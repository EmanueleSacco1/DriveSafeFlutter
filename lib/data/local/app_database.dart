import 'dart:io';

import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;
import 'package:sqlite3_flutter_libs/sqlite3_flutter_libs.dart'; // Ensure this is imported for applyWorkaroundToOpenSqlite3OnOldAndroidVersions

// Import data classes (which will be generated by drift)
part 'app_database.g.dart';

/// Defines the `Cars` table for the Drift database.
///
/// This class specifies the columns and constraints for the `Cars` table.
/// The `@DataClassName('Car')` annotation tells Drift to generate a Dart class
/// named `Car` to represent a row in this table.
@DataClassName('Car') // Specifies the Dart class name for the table row
class Cars extends Table {
  /// The primary key for the table, auto-incrementing.
  IntColumn get id => integer().autoIncrement()();
  /// The brand of the car.
  TextColumn get brand => text()();
  /// The model of the car.
  TextColumn get model => text()();
  /// The manufacturing year of the car.
  IntColumn get year => integer()();
  /// The date when the RCA (car insurance) was paid, stored as a Unix timestamp.
  IntColumn get rcaPaidDate => integer().nullable()();
  /// The date for the next car revision, stored as a Unix timestamp.
  IntColumn get nextRevisionDate => integer().nullable()();
  /// The odometer reading at the time of the last revision.
  IntColumn get revisionOdometer => integer().nullable()();
  /// The registration date of the car, stored as a Unix timestamp.
  IntColumn get registrationDate => integer().nullable()();
  /// The cost of the car tax (bollo).
  RealColumn get bolloCost => real().nullable()();
  /// The expiration date of the car tax (bollo), stored as a Unix timestamp.
  IntColumn get bolloExpirationDate => integer().nullable()();
}

/// The main database class for the application.
///
/// This class defines the database schema, version, and migration strategy.
/// It uses the `Cars` table defined above.
@DriftDatabase(tables: [Cars])
class AppDatabase extends _$AppDatabase {
  /// Creates an instance of the [AppDatabase].
  ///
  /// The database connection is opened lazily using [_openConnection].
  AppDatabase() : super(_openConnection());

  /// The current version of the database schema.
  ///
  /// Increment this number when you make changes to the table structure.
  @override
  int get schemaVersion => 2;

  /// Provides access to the Data Access Object (DAO) for the `Cars` table.
  CarDao get carDao => CarDao(this);

  /// Defines the migration strategy for handling schema changes.
  @override
  MigrationStrategy get migration => MigrationStrategy(
    /// Called when the database is created for the first time.
    onCreate: (Migrator m) {
      return m.createAll();
    },
    /// Called when the [schemaVersion] increases.
    onUpgrade: (Migrator m, int from, int to) async {
      // Example migration: if upgrading from a version less than 2,
      // delete the old 'cars' table and recreate it with the new schema.
      // This is a destructive migration and will result in data loss.
      // For production apps, you should implement a non-destructive migration
      // strategy if possible (e.g., using `m.addColumn`).
      if (from < 2) {
        await m.deleteTable('cars'); // Delete the old table
        await m.createTable(cars);   // Recreate the table with the new schema
      }
    },
  );
}

/// Opens the database connection.
///
/// This function is responsible for:
/// - Applying a workaround for SQLite on older Android versions if necessary.
/// - Finding the application's documents directory.
/// - Creating a [File] object for the database file (`app_database.sqlite`).
/// - Returning a [NativeDatabase] instance.
///
/// This connection is wrapped in a [LazyDatabase] to ensure it's only opened
/// when the database is first accessed.
LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    // Ensure sqlite3_flutter_libs workaround is applied for compatibility
    // with older Android versions.
    if (Platform.isAndroid) {
      await applyWorkaroundToOpenSqlite3OnOldAndroidVersions();
    }
    // Get the directory where the app can store its documents.
    final dbFolder = await getApplicationDocumentsDirectory();
    // Define the path to the database file.
    final file = File(p.join(dbFolder.path, 'app_database.sqlite')); // Name of the database file
    // Create and return the native database connection.
    return NativeDatabase(file);
  });
}

/// Data Access Object (DAO) for the `Cars` table.
///
/// This class provides methods to interact with the `Cars` table,
/// such as inserting, updating, deleting, and querying car records.
/// It uses the `@DriftAccessor` annotation to specify which tables it operates on.
@DriftAccessor(tables: [Cars]) // Specifies that this DAO works with the Cars table
class CarDao extends DatabaseAccessor<AppDatabase> with _$CarDaoMixin {
  /// Creates an instance of [CarDao].
  ///
  /// Requires an [AppDatabase] instance to be attached.
  CarDao(AppDatabase attachedDatabase) : super(attachedDatabase);

  /// Inserts a new car into the database.
  ///
  /// Takes a [CarsCompanion] object, which is a data class used for inserts
  /// and updates in Drift.
  /// Returns a [Future] that completes with the ID of the inserted row.
  Future<int> insertCar(CarsCompanion car) {
    return into(cars).insert(car);
  }

  /// Updates an existing car in the database.
  ///
  /// Takes a [Car] object (the generated data class for a table row).
  /// The car's `id` is used to identify the row to update.
  /// Returns a [Future] that completes when the update is done.
  Future<void> updateCar(Car car) {
    return update(cars).replace(car);
  }

  /// Deletes a car from the database.
  ///
  /// Takes a [Car] object. The car's `id` is used to identify the row to delete.
  /// Returns a [Future] that completes when the deletion is done.
  Future<void> deleteCar(Car car) {
    return (delete(cars)..where((t) => t.id.equals(car.id))).go();
  }

  /// Retrieves all cars from the database as a stream.
  ///
  /// Returns a [Stream] that emits a list of [Car] objects whenever the
  /// data in the `Cars` table changes.
  Stream<List<Car>> getAllCars() {
    return select(cars).watch();
  }

  /// Retrieves a single car by its ID as a stream.
  ///
  /// Takes the `carId` as an argument.
  /// Returns a [Stream] that emits the [Car] object if found, or `null` if not.
  /// The stream updates if the corresponding car data changes.
  Stream<Car?> getCarById(int carId) {
    return (select(cars)..where((t) => t.id.equals(carId))).watchSingleOrNull();
  }
}
